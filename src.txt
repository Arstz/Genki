#pragma once
#include "ByteArray.h"

class Animation
{
	unsigned int keyCount;
	float* timeKeys;
	float* stateKeys;

public:
	Animation(unsigned int keyCount, float* timeKeys, float* stateKeys);
	Animation();
	Animation(const Animation &animation);
	~Animation();
	Animation& operator=(const Animation& animation);
	Animation(ByteArray* byteArray);

	float* getTimeKeysPointer();
	float* getStateKeysPointer();

	ByteArray getByteArray();

	unsigned int getKeyCount() const;
};

#pragma once
#include <list>
#include "AnimationTask.h"

class AnimationController {
	static std::list<AnimationTask> animationTasks;
	static float* frameTime;
public:
	static void destroy();
	static void setTimePointer(float* frameTime);
	static void update();
	static void add(AnimationTask task);
};

#pragma once
#include "Animation.h"

class AnimationTask {
	Animation animation;
	unsigned int counter;
	unsigned int targetCount;
	float timer;
	float** targets;

	float calculatePosition(
		float startPosition,
		float endPosition,
		float startTime,
		float endTime,
		float currentTime
	);

	float calculatePosition(
		float startPosition,
		float endPosition,
		float startTime,
		float endTime,
		float currentTime,
		float limit
	);

public:
	AnimationTask();
	~AnimationTask();
	AnimationTask(const AnimationTask& animationTask);
	AnimationTask& operator=(const AnimationTask& animationTask);

	AnimationTask(const Animation& animation, float* target);

	AnimationTask(const Animation& animation, float** targets, unsigned int targetCount);

	//void animateLoop(float& frameTime);
	bool animate(float& frameTime);
};

#pragma once

class ByteArray {
	char* data;
	unsigned int size;
	unsigned int offset;
public:
	~ByteArray();
	ByteArray();
	ByteArray(const ByteArray& byteArray);
	ByteArray(unsigned int size);
	ByteArray& operator = (const ByteArray& byteArray);
	void add(const ByteArray& byteArray);
	void add(const char* value, unsigned int size);

	template<typename T>
	void add(const T& t) {add((char*)&t, sizeof(t));}

	template<typename T>
	void add(const T* t, unsigned int size) {add((char*)t, size);}

	void read(ByteArray& byteArray);
	void read(char* value, unsigned int size);

	template<typename T>
	void read(T& t) {read((char*)&t, sizeof(t));}

	template<typename T>
	void read(T* t, unsigned int size) {read((char*)t, size);}

	ByteArray& operator << (const ByteArray& byteArray);
	ByteArray& operator >> (const ByteArray& byteArray);

	template<typename T>
	ByteArray& operator << (const T& t) {
		this->add((char*)&t, sizeof(t));
		return *this;
	}

	template<typename T>
	ByteArray& operator >> (const T& t) {
		this->read((char*)&t, sizeof(t));
		return *this;
	}

	unsigned int getSize();
	char* getDataPointer();
	void setOffset(unsigned int offset);
};

#pragma once
#include "Player.h"
#include "ShapeController.h"
#include <chrono>
#include <iostream>
#include "..\include\GLFW\glfw3.h"

class Engine {

private:
	static void pollEvents();

	static float currentTime;
	static float frameTime;
	static std::chrono::system_clock::time_point start;
	static GLFWwindow* window;
	static ShapeController* levelShapeController;
	static Player player;


public:
	static void init();
	static void update();
	static void render();
	static void destroy();
	static void terminate();
	static bool running();
	static void pollKeyEvents();
};

#pragma once
#include "LevelEvent\LevelEvent.h"
#include <list>
#include <vector>
#include <string>

class EventController {
public:
	static std::vector<LevelEvent*> level;
	static int currentEvent;
	static float* currentTime;

	static void update();
	static void destroy();
	
	static void loadLevel(std::string path);
	static void saveLevel(std::string path, std::vector<LevelEvent*>& level);
};

#pragma once
#include "ShapeGroup.h"

class GUIobject {
protected:
	float positionX;
	float positionY;
	ShapeGroup shapeGroup;
	virtual ~GUIobject();
	GUIobject(float positionX, float positionY, ShapeGroup shapeGroup);
public:
	ShapeGroup getShapeGroup();
};

class GUIinteractiveObject : public GUIobject {
public:	
	virtual bool interact(bool mouseButtonStates[3], float x, float y) = 0;
	GUIinteractiveObject(
		float positionX, 
		float positionY, 
		ShapeGroup shapeGroup,
		float LeftBorderX,
		float RightBorderX,
		float UpBorderY,
		float BottomBorderY
	);
protected:
	float LeftBorderX;
	float RightBorderX;
	float UpBorderY;
	float BottomBorderY;
	bool checkCollision(float x, float y);
};

class ButtonSex : public GUIinteractiveObject {
public:
	bool state;
	bool interact(bool mouseButtonStates[3], float x, float y) override;
	ButtonSex(
		float positionX,
		float positionY,
		ShapeGroup shapeGroup,
		float LeftBorderX,
		float RightBorderX,
		float UpBorderY,
		float BottomBorderY
	);
};


class CheckBox : public GUIinteractiveObject {
public:
	bool* state;
};

#pragma once
#define GLEW_STATIC

#include "..\include\GL\glew.h"
#include "..\include\GLFW\glfw3.h"

#include <vector>
#include "GUI.h"
#include "ShapeController.h"

class GUIcanvas
{
private:
	static double mousePositionX;
	static double mousePositionY;
	static bool mouseButtonStates[3];
	
	static int currentButtonID;

	static GLFWwindow* window;
	static std::vector<GUIinteractiveObject*> objects;
	static ShapeController* shapeController;
	static void interact();
public:
	static void setWindow(GLFWwindow* window);
	static void init();
	static void update();
	static void draw();
	static void addGUIobject(GUIinteractiveObject* object);
};

#pragma once
#include <list>
#include "..\Animation.h"
#include "..\AnimationTask.h"
#include "..\Player.h"
#include "..\Shape.h"
#include "..\ShapeGroup.h"
#include "..\AnimationController.h"
#include "..\ShapeController.h"
#include "..\ByteArray.h"
#include <fstream>
#include <vector>

class EventController;

enum class LevelEventType {
	EMPTY,
	BACKGROUND_COLOR_ANIMATION,
	CAMERA_ANIMATION,
	SHAPE_SPAWN,
	SHAPE_GROUP_SPAWN,
	SHAPE_GROUP_DESTRUCTION,
	SHAPE_ANIMATION,
	SHAPE_GROUP_ANIMATION,
	PLAYER_BINDING,
};

enum class AnimatedValueType {
	VERTEX_POSITION,
	VERTEX_COLOR,	
	ALPHA_CHANNEL,
	POSITION_X,
	POSITION_Y,
	SHAPE_COLOR
};


class LevelEvent {
	friend EventController;
protected:
	float initTime;
	LevelEventType type;	
	LevelEvent();
	virtual ~LevelEvent();
	LevelEvent(float initTime);
	static std::list<ShapeGroup>::iterator* shapeGroups;
	static ShapeController* shapeController;
public:
	virtual void start();
	virtual ByteArray getByteArray();
	float getInitTime();
	static void setShapeController(ShapeController* shapeController);
	static void setShapeGroupsSize(unsigned int size);

	LevelEventType getType();
};


class BackgroundColorAnimationEvent : public LevelEvent {
	Animation animation;
	uint valueNum;

	BackgroundColorAnimationEvent(Animation animation, uint valueNum, float initTime);
public:
	static BackgroundColorAnimationEvent* create(
		Animation animation,
		uint valueNum,
		float initTime
	);
	static BackgroundColorAnimationEvent* create(
		ByteArray* byteArray,
		float initTime
	);
	void start() override;
	ByteArray getByteArray() override;
};


class CameraAnimationEvent : public LevelEvent {
	Animation animation;
	uint valueNum;

	CameraAnimationEvent(
		Animation animation,
		uint valueNum,
		float initTime
	);

public:
	static CameraAnimationEvent* create(
		Animation animation,
		uint valueNum,
		float initTime
	);

	static CameraAnimationEvent* create(
		ByteArray* byteArray,
		float initTime
	);

	void start() override;
	ByteArray getByteArray() override;
};


class PlayerBindingEvent : public LevelEvent {
	PlayerBindingEvent(int shapeGroupID, float initTime);
	int shapeGroupID;
public:
	static Player* player;
	static PlayerBindingEvent* create(
		int shapeGroupID,
		float initTime
	);
	static PlayerBindingEvent* create(
		ByteArray* byteArray,
		float initTime
	);
	void start() override;
	ByteArray getByteArray() override;
};


class ShapeAnimationEvent : public LevelEvent {
	Animation animation;
	AnimatedValueType animatedValueType;
	int shapeGroupID;
	int shapeNum;
	int vertexNum;
	int valueNum;
	ShapeAnimationEvent(
		Animation animation,
		AnimatedValueType animatedValueType,
		int shapeGroupID,
		int shapeNum,
		int vertexNum,
		int valueNum,
		float initTime
	);
	ShapeAnimationEvent(
		Animation animation,
		AnimatedValueType animatedValueType,
		int shapeGroupID,
		int shapeNum,
		int valueNum,
		float initTime
	);
public:

	static ShapeAnimationEvent* create(
		Animation animation,
		AnimatedValueType animatedValueType,
		int shapeGroupID,
		int shapeNum,
		int vertexNum,
		int valueNum,
		float initTime
	);
	static ShapeAnimationEvent* create(
		Animation animation,
		AnimatedValueType animatedValueType,
		int shapeGroupID,
		int shapeNum,
		int valueNum,
		float initTime
	);
	static ShapeAnimationEvent* create(
		ByteArray* byteArray,
		float initTime
	);

	void start() override;
	ByteArray getByteArray() override;
};


class ShapeGroupAnimationEvent : public LevelEvent {
	Animation animation;
	AnimatedValueType animatedValueType;
	int shapeGroupID;

	ShapeGroupAnimationEvent(
		Animation animation,
		AnimatedValueType animatedValueType,
		int shapeGroupID,
		float initTime
	);
public:

	static ShapeGroupAnimationEvent* create(
		Animation animation,
		AnimatedValueType animatedValueType,
		int shapeGroupID,
		float initTime
	);
	static ShapeGroupAnimationEvent* create(
		ByteArray* byteArray,
		float initTime
	);

	void start() override;
	ByteArray getByteArray() override;
};


class ShapeGroupDestructionEvent : public LevelEvent { //opasniy pizdets
	int shapeGroupID;
	ShapeGroupDestructionEvent(int shapeGroupID, float initTime);
public:

	static ShapeGroupDestructionEvent* create(
		int shapeGroupID,
		float initTime
	);

	static ShapeGroupDestructionEvent* create(
		ByteArray* byteArray,
		float initTime
	);

	void start() override;
	ByteArray getByteArray() override;
};


class ShapeGroupSpawnEvent : public LevelEvent {
	ShapeGroup shapeGroup;
	int shapeGroupID;
	int targetShapeGroupID;

	ShapeGroupSpawnEvent(
		ShapeGroup shapeGroup,
		int shapeGroupID,
		int targetShapeGroupID,
		float initTime
	);
public:
	static ShapeGroupSpawnEvent* create(
		ShapeGroup shapeGroup,
		int shapeGroupID,
		int targetShapeGroupID,
		float initTime
	);
	static ShapeGroupSpawnEvent* create(
		ByteArray* byteArray,
		float initTime
	);
	ByteArray getByteArray() override;
	void start() override;
};


class ShapeSpawnEvent : public LevelEvent {
	int shapeGroupID;
	int targetShapeGroupID;
	Shape shape;
	ShapeSpawnEvent(
		Shape shape,
		int shapeGroupID,
		int targetShapeGroupID,
		float initTime
	);
public:
	static ShapeSpawnEvent* create(
		Shape shape,
		int shapeGroupID,
		int targetShapeGroupID,
		float initTime
	);
	static ShapeSpawnEvent* create(
		ByteArray* byteArray,
		float initTime
	);
	void start() override;

	ByteArray getByteArray() override;
};

#pragma once
#include "Shape.h"
#include "..\include\GL\glew.h"
#include "..\include\GLFW\glfw3.h"

class Player {
	float* positionX;
	float* positionY;
public:
	int lastDirectionX;
	int lastDirectionY;

	void move(float dx, float dy);

	void setTarget(float* positionX, float* positionY);
};

#pragma once
#include "ByteArray.h"
typedef unsigned int uint;

class Shape {
	uint vertexCount;
	uint EBOsize;

	uint* vertexIDs;

	int layer;	

	float alphaChannel;

	float positionX;
	float positionY;

	float* vertexCoords;
	float* vertexColors;	
public:
	Shape();
	Shape(
		uint vertexCount,
		float* vertexCoords,
		float* vertexColors,
		uint EBOsize,
		uint* vertexIDs,
		float alphaChannel,
		float positionX,
		float positionY,
		int layer
	);

	Shape(const Shape& shape);
	Shape(ByteArray* byteArray);
	~Shape();

	Shape& operator=(const Shape& shape);

	uint getVertexCount() const;
	uint getEBOsize() const;

	float* getVertexCoordsPointer();
	float* getVertexColorsPointer();

	uint* getVertexIDsPointer();

	float* getAlphaChannelPointer();
	float* getPositionXpointer();
	float* getPositionYpointer();

	int getLayer() const;
	ByteArray getByteArray();
};

#pragma once
#include "Window.h"
#include "Shape.h"
#include "ShapeGroup.h"
#include <list>

#define VERTEX_SIZE 6ul
#define CAMERA_DATA_SIZE 4u
#define VERTEX_ATTRIB_ARRAY_1 0
#define VERTEX_ATTRIB_ARRAY_2 1

class ShapeController {
private:
	static int shader;

	GLuint bufferID;
	GLuint VBO;
	GLuint VAO;
	GLuint EBO;
	GLuint CDB;

	uint EBOsize;
	uint vertexCount;

	uint* EBObuffer;

	float cameraDataBuffer[4];

	float* vertexBuffer;	

	ShapeGroup shapeGroup;

	static GLFWwindow* window;

	void updateBuffers();
	void reallocateBuffers();
	void initBuffers();
		

	void writeToVertexbuffer(
		ShapeGroup& shapeGroup,
		uint& positionOffsetCounter,
		uint& colorOffsetCounter,
		float alphaChannel,
		float positionX,
		float positionY
	);
	void writeToEBObuffer(
		ShapeGroup& shapeGroup,
		uint& EBOoffsetCounter,
		uint& vertexCounter
	);

public:
	static void initShader();
	void destroy();
	void draw();
	
	static void setWindow(GLFWwindow* window);
	void removeShapeGroup(std::list<ShapeGroup>::iterator& shapeIterator);

	float* getCameraValuePointer(uint valueNum);

	std::list<ShapeGroup>::iterator addShapeGroup(const ShapeGroup& shapeGroup);
	std::list<ShapeGroup>::iterator addShapeGroup(
		const ShapeGroup& shapeGroup, 
		const std::list<ShapeGroup>::iterator& shapeGroupIterator
	);

	ShapeController();
//	ShapeController& operator=(const ShapeController& shapeController);
//	ShapeController(const ShapeController& shapeController);
	~ShapeController();
};

#pragma once
#include "Shape.h"
#include <list>
#include <vector>

class ShapeGroup {
	uint shapeCount;

	int layer;

	float alphaChannel;
	float positionX;
	float positionY;

	Shape* shapes;
	std::list<ShapeGroup> shapeGroups;
public:
	ShapeGroup();
	ShapeGroup(
		uint shapeCount,
		Shape* shapes,
		float alphaChannel,
		float positionX,
		float positionY,
		int layer
	);
	ShapeGroup(const Shape &shape);
	ShapeGroup(const ShapeGroup& shapeGroup);
	ShapeGroup(ByteArray* byteArray);
	~ShapeGroup();
	ShapeGroup& operator=(const ShapeGroup& shapeGroup);

	std::list<ShapeGroup>::iterator addShapeGroup(const ShapeGroup& shapeGroup);
	void removeShapeGroup(const std::list<ShapeGroup>::iterator& shapeGroupIterator);

	float* getAlphaChannelPointer();
	float* getPositionXpointer();
	float* getPositionYpointer();

	int getLayer() const;

	uint getEBOsize() const;
	uint getVertexCount() const;

	uint getShapeCount() const;

	Shape* getShapesPointer();
	std::list<ShapeGroup> getShapeGroups();
	ByteArray getByteArray();
};

#pragma once
#define GLEW_STATIC

#include "..\include\GL\glew.h"
#include "..\include\GLFW\glfw3.h"

typedef unsigned int uint;

class Window {
	static GLFWwindow* window;
	static float backgroundColor[4];
	static GLuint currentBufferID;
	static GLuint currentAttribArrayID;
public:
	static GLuint generateBufferID();
	static GLuint generateAttribArray();
	static void init();
	static GLFWwindow* getWindow();
	static float* getBackgroundColorValuePointer(uint valueNum);
	static bool running();
	static void clear();
};

#include "LevelEvent.h"

BackgroundColorAnimationEvent::BackgroundColorAnimationEvent(
	Animation animation, 
	uint valueNum, 
	float initTime
): LevelEvent(initTime) {
	this->type = LevelEventType::BACKGROUND_COLOR_ANIMATION;
	this->animation = animation;
	this->valueNum = valueNum;
}

BackgroundColorAnimationEvent* BackgroundColorAnimationEvent::create(
	Animation animation,
	uint valueNum,
	float initTime
) {
	return new BackgroundColorAnimationEvent(animation, valueNum, initTime);
}

BackgroundColorAnimationEvent* BackgroundColorAnimationEvent::create(
	ByteArray* byteArray,
	float initTime
) {
	uint valueNum;
	*byteArray >> valueNum;
	return new BackgroundColorAnimationEvent(Animation(byteArray), valueNum, initTime);
}

void BackgroundColorAnimationEvent::start() {
	AnimationController::add(AnimationTask(animation, Window::getBackgroundColorValuePointer(valueNum)));
}

ByteArray BackgroundColorAnimationEvent::getByteArray() {
	ByteArray animationArray = animation.getByteArray();
	ByteArray byteArray(animationArray.getSize() + sizeof(valueNum));
	byteArray << valueNum << animationArray;
	return byteArray;
}

#include "LevelEvent.h"

CameraAnimationEvent::CameraAnimationEvent(
	Animation animation,
	uint valueNum,
	float initTime
): LevelEvent::LevelEvent(initTime) {
	this->animation = animation;
	this->valueNum = valueNum;
	this->type = LevelEventType::CAMERA_ANIMATION;
}

CameraAnimationEvent* CameraAnimationEvent::create(Animation animation, uint valueNum, float initTime) {
	return new CameraAnimationEvent(animation, valueNum, initTime);
}

CameraAnimationEvent* CameraAnimationEvent::create(
	ByteArray* byteArray,
	float initTime
) {
	uint valueNum;
	*byteArray >> valueNum;
	return new CameraAnimationEvent(Animation(byteArray), valueNum, initTime);
}

void CameraAnimationEvent::start() {
	AnimationController::add(AnimationTask(animation, shapeController->getCameraValuePointer(valueNum)));
}

ByteArray CameraAnimationEvent::getByteArray() {
	ByteArray animationArray = animation.getByteArray();
	ByteArray byteArray(animationArray.getSize() + sizeof(valueNum));
	byteArray << valueNum << animationArray;
	return byteArray;
}

#include "LevelEvent.h"

std::list<ShapeGroup>::iterator* LevelEvent::shapeGroups = nullptr;
ShapeController* LevelEvent::shapeController = nullptr;

float LevelEvent::getInitTime() {
	return initTime;
}

void LevelEvent::setShapeController(ShapeController* shapeController) {
	LevelEvent::shapeController = shapeController;
}

void LevelEvent::setShapeGroupsSize(unsigned int size) {
	delete[] shapeGroups;
	LevelEvent::shapeGroups = new std::list<ShapeGroup>::iterator[size];
}

LevelEvent::LevelEvent(){
	this->initTime = 0;
	this->type = LevelEventType::EMPTY;
}

LevelEvent::~LevelEvent() {}

LevelEvent::LevelEvent(float initTime) {
	this->initTime = initTime;
	this->type = LevelEventType::EMPTY;
}

LevelEventType LevelEvent::getType() {
	return type;
}

void LevelEvent::start() {}

ByteArray LevelEvent::getByteArray() {
	return ByteArray();
}

#include "LevelEvent.h"

Player* PlayerBindingEvent::player = nullptr;

PlayerBindingEvent::PlayerBindingEvent(int shapeGroupID, float initTime) : LevelEvent(initTime) {
	this->shapeGroupID = shapeGroupID;
	this->type = LevelEventType::PLAYER_BINDING;
}
PlayerBindingEvent* PlayerBindingEvent::create(int shapeGroupID, float initTime) {
	return new PlayerBindingEvent(shapeGroupID, initTime);
}

PlayerBindingEvent* PlayerBindingEvent::create(
	ByteArray* byteArray,
	float initTime
) {
	int shapeGroupID;
	*byteArray >> shapeGroupID;
	return new PlayerBindingEvent(shapeGroupID, initTime);
}

void PlayerBindingEvent::start() {
	player->setTarget(
		(*(shapeGroups[shapeGroupID])).getPositionXpointer(),
		(*(shapeGroups[shapeGroupID])).getPositionYpointer()
	);
}

ByteArray PlayerBindingEvent::getByteArray() {
	ByteArray byteArray(sizeof(shapeGroupID));
	byteArray << shapeGroupID;
	return byteArray;
}

#include "LevelEvent.h"

ShapeAnimationEvent::ShapeAnimationEvent(
	Animation animation,
	AnimatedValueType animatedValueType,
	int shapeGroupID,
	int shapeNum,
	int vertexNum,
	int valueNum,
	float initTime
): LevelEvent(initTime) {
	this->animation = animation;
	this->animatedValueType = animatedValueType;
	this->shapeGroupID = shapeGroupID;
	this->shapeNum = shapeNum;
	this->vertexNum = vertexNum;
	this->valueNum = valueNum;
	this->type = LevelEventType::SHAPE_ANIMATION;
}

ShapeAnimationEvent::ShapeAnimationEvent(
	Animation animation,
	AnimatedValueType animatedValueType,
	int shapeGroupID,
	int shapeNum,
	int valueNum,
	float initTime
) : LevelEvent(initTime) {
	this->animation = animation;
	this->animatedValueType = animatedValueType;
	this->shapeGroupID = shapeGroupID;
	this->shapeNum = shapeNum;
	this->valueNum = valueNum;
	this->type = LevelEventType::SHAPE_ANIMATION;
}

ShapeAnimationEvent* ShapeAnimationEvent::create(
	Animation animation,
	AnimatedValueType animatedValueType,
	int shapeGroupID,
	int shapeNum,
	int vertexNum,
	int valueNum,
	float initTime
) {
	return new ShapeAnimationEvent(
		animation,
		animatedValueType,
		shapeGroupID,
		shapeNum,
		vertexNum,
		valueNum,
		initTime
	);
}

ShapeAnimationEvent* ShapeAnimationEvent::create(
	Animation animation,
	AnimatedValueType animatedValueType,
	int shapeGroupID,
	int shapeNum,
	int valueNum,
	float initTime
) {
	return new ShapeAnimationEvent(
		animation,
		animatedValueType,
		shapeGroupID,
		shapeNum,
		valueNum,
		initTime
	);
}

ShapeAnimationEvent* ShapeAnimationEvent::create(
	ByteArray* byteArray,
	float initTime
) {
	AnimatedValueType animatedValueType;
	int shapeGroupID, shapeNum, vertexNum, valueNum;
	*byteArray >> animatedValueType >> shapeGroupID >> shapeNum >> vertexNum >> valueNum;
	return new ShapeAnimationEvent(
		Animation(byteArray),
		animatedValueType,
		shapeGroupID,
		shapeNum,
		vertexNum,
		valueNum,
		initTime
	);
}

void ShapeAnimationEvent::start() {
	Shape* shape = &(*shapeGroups[shapeGroupID]).getShapesPointer()[shapeNum];
	if (animatedValueType != AnimatedValueType::SHAPE_COLOR) { //UUUuuu kostyl
		float* target;
		switch (animatedValueType) {
		case AnimatedValueType::VERTEX_POSITION:
			target = &shape->getVertexCoordsPointer()[vertexNum * 2 + valueNum];
			break;
		case AnimatedValueType::VERTEX_COLOR:
			target = &shape->getVertexColorsPointer()[vertexNum * 4 + valueNum];
			break;
		case AnimatedValueType::ALPHA_CHANNEL:
			target = shape->getAlphaChannelPointer();
			break;
		case AnimatedValueType::POSITION_X:
			target = shape->getPositionXpointer();
			break;
		case AnimatedValueType::POSITION_Y:
			target = shape->getPositionYpointer();
			break;
		default:
			throw "WRONG ANIMATED VALUE TYPE";
			break;
		}
		AnimationController::add(AnimationTask(animation, target));
	}
	else {
		unsigned int shapeVertexCount = shape->getVertexCount();
		float** targets = new float* [shapeVertexCount];
		for (unsigned int i = 0; i < shapeVertexCount; i++) {
			targets[i] = &shape->getVertexColorsPointer()[valueNum + i * 4];
		}
		AnimationController::add(AnimationTask(animation, targets, shapeVertexCount));
		delete[] targets;
		targets = nullptr;
	}
}

ByteArray ShapeAnimationEvent::getByteArray() {
	ByteArray animationArray = animation.getByteArray();
	ByteArray byteArray(
		animationArray.getSize() +
		sizeof(animatedValueType) +
		sizeof(shapeGroupID) +
		sizeof(shapeNum) +
		sizeof(vertexNum) +
		sizeof(valueNum)
	);
	byteArray << animatedValueType << shapeGroupID << shapeNum << vertexNum << valueNum << animationArray;
	return byteArray;
}

#include "LevelEvent.h"

ShapeGroupAnimationEvent::ShapeGroupAnimationEvent(
	Animation animation,
	AnimatedValueType animatedValueType,
	int shapeGroupID,
	float initTime
): LevelEvent(initTime) {
	this->animation = animation;
	this->animatedValueType = animatedValueType;
	this->shapeGroupID = shapeGroupID;
	this->type = LevelEventType::SHAPE_GROUP_ANIMATION;
}

ShapeGroupAnimationEvent* ShapeGroupAnimationEvent::create(
	Animation animation,
	AnimatedValueType animatedValueType,
	int shapeGroupID,
	float initTime
) {
	return new ShapeGroupAnimationEvent(
		animation,
		animatedValueType,
		shapeGroupID,
		initTime
	);
}

ShapeGroupAnimationEvent* ShapeGroupAnimationEvent::create(
	ByteArray* byteArray,
	float initTime
) {
	AnimatedValueType animatedValueType;
	int shapeGroupID;
	*byteArray >> animatedValueType >> shapeGroupID;
	return new ShapeGroupAnimationEvent(
		Animation(byteArray),
		animatedValueType,
		shapeGroupID,
		initTime
	);
}

void ShapeGroupAnimationEvent::start() {
	float* target;

	ShapeGroup* shapeGroup = &(*shapeGroups[shapeGroupID]);

	switch (animatedValueType) {
	case AnimatedValueType::ALPHA_CHANNEL:
		target = shapeGroup->getAlphaChannelPointer();
		break;
	case AnimatedValueType::POSITION_X:
		target = shapeGroup->getPositionXpointer();
		break;
	case AnimatedValueType::POSITION_Y:
		target = shapeGroup->getPositionYpointer();
		break;
	default:
		throw "WRONG ANIMATED VALUE TYPE";
		break;
	}
	AnimationController::add(AnimationTask(animation, target));
}

ByteArray ShapeGroupAnimationEvent::getByteArray() {
	ByteArray animationArray = animation.getByteArray();
	ByteArray byteArray(
		animationArray.getSize() +
		sizeof(animatedValueType) +
		sizeof(shapeGroupID)
	);
	byteArray << animatedValueType << shapeGroupID << animationArray;
	return byteArray;
}

#include "LevelEvent.h"

ShapeGroupDestructionEvent::ShapeGroupDestructionEvent(int shapeGroupID, float initTime): LevelEvent(initTime) {
	this->shapeGroupID = shapeGroupID;
	this->type = LevelEventType::SHAPE_GROUP_DESTRUCTION;
}

ShapeGroupDestructionEvent* ShapeGroupDestructionEvent::create(int shapeGroupID, float initTime) {
	return new ShapeGroupDestructionEvent(shapeGroupID, initTime);
}

ShapeGroupDestructionEvent* ShapeGroupDestructionEvent::create(
	ByteArray* byteArray,
	float initTime
) {
	int shapeGroupID;
	*byteArray >> shapeGroupID;
	return new ShapeGroupDestructionEvent(shapeGroupID, initTime);
}

void ShapeGroupDestructionEvent::start() {
	shapeController->removeShapeGroup(shapeGroups[shapeGroupID]);
}

ByteArray ShapeGroupDestructionEvent::getByteArray() {
	ByteArray byteArray(sizeof(shapeGroupID));
	byteArray >> shapeGroupID;
	return byteArray;
}

#include "LevelEvent.h"

ShapeGroupSpawnEvent::ShapeGroupSpawnEvent(
	ShapeGroup shapeGroup,
	int shapeGroupID,
	int targetShapeGroupID,
	float initTime
): LevelEvent(initTime) {
	this->shapeGroupID = shapeGroupID;
	this->shapeGroup = shapeGroup;
	this->type = LevelEventType::SHAPE_GROUP_SPAWN;
}

ShapeGroupSpawnEvent* ShapeGroupSpawnEvent::create(ShapeGroup shapeGroup, int shapeGroupID, int targetShapeGroupID, float initTime) {
	return new ShapeGroupSpawnEvent(shapeGroup, shapeGroupID, targetShapeGroupID, initTime);
}

ShapeGroupSpawnEvent* ShapeGroupSpawnEvent::create(
	ByteArray* byteArray,
	float initTime
) {
	int shapeGroupID, targetShapeGroupID;
	*byteArray >> shapeGroupID >> targetShapeGroupID;
	return new ShapeGroupSpawnEvent(ShapeGroup(byteArray), shapeGroupID, targetShapeGroupID, initTime);
}

ByteArray ShapeGroupSpawnEvent::getByteArray() {
	ByteArray shapeGroupArray = shapeGroup.getByteArray();
	ByteArray byteArray(
		shapeGroupArray.getSize() +
		sizeof(shapeGroupID) +
		sizeof(targetShapeGroupID)
	);
	byteArray << shapeGroupID << targetShapeGroupID << shapeGroupArray;
	return byteArray;
}

void ShapeGroupSpawnEvent::start() {
	if (targetShapeGroupID) shapeGroups[shapeGroupID] = shapeController->addShapeGroup(shapeGroup, shapeGroups[targetShapeGroupID]);
	else shapeGroups[shapeGroupID] = shapeController->addShapeGroup(shapeGroup);
}

#include "LevelEvent.h"

ShapeSpawnEvent* ShapeSpawnEvent::create(Shape shape, int shapeGroupID, int targetShapeGroupID, float initTime) {
	return new ShapeSpawnEvent(shape, shapeGroupID, targetShapeGroupID, initTime);
}

ShapeSpawnEvent* ShapeSpawnEvent::create(
	ByteArray* byteArray,
	float initTime
) {
	int shapeGroupID, targetShapeGroupID;
	*byteArray >> shapeGroupID >> targetShapeGroupID;
	return new ShapeSpawnEvent(Shape(byteArray), shapeGroupID, targetShapeGroupID, initTime);
}

ShapeSpawnEvent::ShapeSpawnEvent(
	Shape shape,
	int shapeGroupID,
	int targetShapeGroupID,
	float initTime
): LevelEvent(initTime) {
	this->shapeGroupID = shapeGroupID;
	this->targetShapeGroupID = targetShapeGroupID;
	this->shape = shape;
	this->type = LevelEventType::SHAPE_SPAWN;
}

void ShapeSpawnEvent::start() {
	if (targetShapeGroupID) shapeGroups[shapeGroupID] = shapeController->addShapeGroup(ShapeGroup(shape), shapeGroups[targetShapeGroupID]);
	else shapeGroups[shapeGroupID] = shapeController->addShapeGroup(ShapeGroup(shape));
}

ByteArray ShapeSpawnEvent::getByteArray() {
	ByteArray shapeArray = shape.getByteArray();
	ByteArray byteArray(
		shapeArray.getSize() +
		sizeof(shapeGroupID) +
		sizeof(targetShapeGroupID)
	);
	byteArray << shapeGroupID << targetShapeGroupID << shapeArray;
	return byteArray;
}

#pragma once
#include "Animation.h"

#include "crtdbg.h"
#include "..\include\CRTDBG\mydbgnew.h"
#ifdef _DEBUG
#define new MYDEBUG_NEW
#endif

Animation::Animation() {
	keyCount = 0;
	timeKeys = nullptr;
	stateKeys = nullptr;
}

Animation::Animation(const Animation& animation) {
	this->keyCount = animation.keyCount;

	this->timeKeys = new float[keyCount];
	this->stateKeys = new float[keyCount];

	for (int i = 0; i < keyCount; i++) {
		this->timeKeys[i] = animation.timeKeys[i];
		this->stateKeys[i] = animation.stateKeys[i];
	}
}

Animation::Animation(unsigned int keyCount, float* timeKeys, float* stateKeys) {
	this->keyCount = keyCount;

	this->timeKeys = new float[keyCount];
	this->stateKeys = new float[keyCount];

	for (int i = 0; i < keyCount; i++) {
		this->timeKeys[i] = timeKeys[i];
		this->stateKeys[i] = stateKeys[i];
	}
}

Animation::~Animation() {
	delete[] timeKeys;
	delete[] stateKeys;
	timeKeys = nullptr;
	stateKeys = nullptr;
}

Animation& Animation::operator=(const Animation& animation) {
	delete[] this->timeKeys;
	delete[] this->stateKeys;

	this->keyCount = animation.keyCount;

	this->timeKeys = new float[keyCount];
	this->stateKeys = new float[keyCount];

	for (int i = 0; i < keyCount; i++) {
		this->timeKeys[i] = animation.timeKeys[i];
		this->stateKeys[i] = animation.stateKeys[i];
	}
	return *this;
}

Animation::Animation(ByteArray* byteArray) {
	*byteArray >> keyCount;
	this->timeKeys = new float[keyCount];
	this->stateKeys = new float[keyCount];
	byteArray->read(timeKeys, sizeof(*timeKeys) * keyCount);
	byteArray->read(stateKeys, sizeof(*stateKeys) * keyCount);
}

float* Animation::getTimeKeysPointer() {
	return timeKeys;
}

float* Animation::getStateKeysPointer() {
	return stateKeys;
}

ByteArray Animation::getByteArray() {
	ByteArray byteArray(sizeof(keyCount) + (sizeof(*timeKeys) + sizeof(*stateKeys)) * keyCount);

	byteArray.add(keyCount);
	byteArray.add(timeKeys, sizeof(*timeKeys) * keyCount);
	byteArray.add(stateKeys, sizeof(*stateKeys) * keyCount);

	return byteArray;
}

unsigned int Animation::getKeyCount() const {
	return keyCount;
}

#include "AnimationController.h"

#include "crtdbg.h"
#include "..\include\CRTDBG\mydbgnew.h"
#ifdef _DEBUG
#define new MYDEBUG_NEW
#endif

std::list<AnimationTask> AnimationController::animationTasks = std::list<AnimationTask>();
float* AnimationController::frameTime = nullptr;

void AnimationController::destroy(){
	animationTasks.~list();
}

void AnimationController::setTimePointer(float* frameTime) {
	AnimationController::frameTime = frameTime;
}

void AnimationController::update() {
	std::list<AnimationTask>::iterator i = animationTasks.begin(); 
	while (i != animationTasks.end()) {
		if ((*i).animate(*frameTime)) {
			i = animationTasks.erase(i);
		} else i++;
	}
}

void AnimationController::add(AnimationTask task) {
	animationTasks.push_back(task);
}

#include "AnimationTask.h"
#include <iostream>

#include "crtdbg.h"
#include "..\include\CRTDBG\mydbgnew.h"
#ifdef _DEBUG
#define new MYDEBUG_NEW
#endif

#define M_PI 3.14159265358979323846f  /* pipiska */

AnimationTask::AnimationTask() {
	this->targets = nullptr;
	this->counter = 0;
	this->timer = 0;
	this->targetCount = 0;
}

AnimationTask::~AnimationTask() {
	delete[] targets;
	targets = nullptr;
}

AnimationTask::AnimationTask(const AnimationTask& animationTask)
{
	this->animation = animationTask.animation;
	this->targets = new float* [animationTask.targetCount];
	for (unsigned int i = 0; i < animationTask.targetCount; i++) {
		this->targets[i] = animationTask.targets[i];
	}
	this->counter = 0;
	this->timer = 0;
	this->targetCount = animationTask.targetCount;
}

AnimationTask& AnimationTask::operator=(const AnimationTask& animationTask)
{
	delete[] targets;
	targets = nullptr;

	this->animation = animationTask.animation;
	this->targets = new float* [animationTask.targetCount];
	for (unsigned int i = 0; i < animationTask.targetCount; i++) {
		this->targets[i] = animationTask.targets[i];
	}
	this->counter = 0;
	this->timer = 0;
	this->targetCount = animationTask.targetCount;

	return *this;
}

AnimationTask::AnimationTask(const Animation& animation, float* target) {
	this->animation = animation;
	this->targets = new float*[] { target };
	this->counter = 0;
	this->timer = 0;
	this->targetCount = 1;
}

AnimationTask::AnimationTask(
	const Animation& animation,
	float** targets,
	unsigned int targetCount
) {
	this->animation = animation;
	this->targets = new float*[targetCount];
	for (unsigned int i = 0; i < targetCount; i++) {
		this->targets[i] = targets[i];
	}
	this->counter = 0;
	this->timer = 0;
	this->targetCount = targetCount;
}

float AnimationTask::calculatePosition(
	float startPosition, 
	float endPosition, 
	float startTime, 
	float endTime, 
	float currentTime
) {
	return startPosition + (endPosition - startPosition) * ((currentTime - startTime) / (endTime - startTime));
}

float AnimationTask::calculatePosition(
	float startPosition, 
	float endPosition, 
	float startTime, 
	float endTime, 
	float currentTime, 
	float limit
) {
	if (float(endPosition - startPosition) < float(-limit / 2)) {	
		startPosition -= limit;
	}
	else if (float(endPosition - startPosition) > float(limit / 2)) {
		endPosition -= limit;
	}
	return startPosition + (endPosition - startPosition) * ((currentTime - startTime) / (endTime - startTime));
}


/*void AnimationTask::animateLoop(float& frameTime) {
	timer += frameTime;
	while (timer > animation.getTimeKeysPointer()[counter]) {
		counter += 1;
		if (counter == animation.getKeyCount()) {
			timer -= animation.getTimeKeysPointer()[counter - 1];
			counter = 0;
		}
	}
	if (counter) {
		*target = calculatePosition(
			animation.getStateKeysPointer()[counter - 1],
			animation.getStateKeysPointer()[counter],
			animation.getTimeKeysPointer()[counter - 1],
			animation.getTimeKeysPointer()[counter],
			timer
		);
	}
	else {
		*target = calculatePosition(
			animation.getStateKeysPointer()[(counter + animation.getKeyCount() - 1) % animation.getKeyCount()],
			animation.getStateKeysPointer()[counter],
			0.f,
			animation.getTimeKeysPointer()[counter],
			timer
		);
	}
}
*/ 
//potom peredelaem

bool AnimationTask::animate(float& frameTime) {
	timer += frameTime;
	while (timer > animation.getTimeKeysPointer()[counter + 1]) {
		counter ++;
		if (counter == animation.getKeyCount() - 1) {
			float value = animation.getStateKeysPointer()[animation.getKeyCount() - 1];
			for (unsigned int i = 0; i < targetCount; i++) {
				*targets[i] = value;
			}
			return true; //finished
		}
	}
	float value = calculatePosition(
		animation.getStateKeysPointer()[counter],
		animation.getStateKeysPointer()[counter + 1],
		animation.getTimeKeysPointer()[counter],
		animation.getTimeKeysPointer()[counter + 1],
		timer
	);
	for (unsigned int i = 0; i < targetCount; i++) {
		*targets[i] = value;
	}

	return false;
}

#include "ByteArray.h"

#include "crtdbg.h"
#include "..\include\CRTDBG\mydbgnew.h"
#ifdef _DEBUG
#define new MYDEBUG_NEW
#endif

ByteArray::~ByteArray() {
	delete[] data;
	data = nullptr;
}

ByteArray::ByteArray() {
	data = nullptr;
	size = 0;
	offset = 0;
}

ByteArray::ByteArray(const ByteArray& byteArray) {
	size = byteArray.size;
	offset = byteArray.offset;
	data = new char[size];
	for (unsigned int i = 0; i < size; i++) data[i] = byteArray.data[i];
}

ByteArray::ByteArray(unsigned int size) {
	this->size = size;
	this->offset = 0;
	this->data = new char[size];
}

ByteArray& ByteArray::operator=(const ByteArray& byteArray) {
	delete[] data;
	size = byteArray.size;
	offset = byteArray.offset;
	data = new char[size];
	for (unsigned int i = 0; i < size; i++) data[i] = byteArray.data[i];
	return *this;
}

void ByteArray::add(const ByteArray& byteArray) {
	for (unsigned int i = 0; i < byteArray.size; i++) data[offset + i] = byteArray.data[i];
	offset += byteArray.size;
}

void ByteArray::add(const char* value, unsigned int size) {
	for (int i = 0; i < size; i++) data[offset + i] = value[i];
	offset += size;
}

void ByteArray::read(ByteArray& byteArray) {
	for (unsigned int i = 0; i < byteArray.size; i++) byteArray.data[i] = data[offset + i];
	offset += byteArray.size;
}

ByteArray& ByteArray::operator << (const ByteArray& byteArray) {
	this->add(byteArray);
	return *this;
}

ByteArray& ByteArray::operator >> (const ByteArray& byteArray) {
	this->read(byteArray);
	return *this;
}

void ByteArray::read(char* value, unsigned int size) {
	for (int i = 0; i < size; i++) value[i] = data[offset + i];
	offset += size;
}

unsigned int ByteArray::getSize() {
	return size;
}

char* ByteArray::getDataPointer() {
	return data;
}

void ByteArray::setOffset(unsigned int offset) {
	this->offset = offset;
}

#include "Engine.h"
#include "EventController.h"
#include "AnimationController.h"
#include "Shape.h"
#include "ShapeGroup.h"
#include "LevelEvent\LevelEvent.h"
#include "Window.h"
#include "ShapeController.h"
#include "GUIcanvas.h"
#include "GUI.h"

#include "crtdbg.h"
#include "..\include\CRTDBG\mydbgnew.h"
#ifdef _DEBUG
#define new MYDEBUG_NEW
#endif

#define AAAA (static_cast <float> (rand()) / static_cast <float> (RAND_MAX))
#define BBBB (2.f*static_cast <float> (rand()) / static_cast <float> (RAND_MAX) - 1)/2

#define IS_RIGHT_KEY_PRESSED (glfwGetKey(window, GLFW_KEY_RIGHT) == GLFW_PRESS)
#define IS_LEFT_KEY_PRESSED (glfwGetKey(window, GLFW_KEY_LEFT) == GLFW_PRESS)
#define IS_UP_KEY_PRESSED (glfwGetKey(window, GLFW_KEY_UP) == GLFW_PRESS)
#define IS_DOWN_KEY_PRESSED (glfwGetKey(window, GLFW_KEY_DOWN) == GLFW_PRESS)

float Engine::currentTime = 0;
float Engine::frameTime = 0;
std::chrono::system_clock::time_point Engine::start = std::chrono::system_clock::now();
GLFWwindow* Engine::window = nullptr;
ShapeController* Engine::levelShapeController = nullptr;
Player Engine::player = Player();

void Engine::destroy()
{
	AnimationController::destroy();
	levelShapeController->destroy();
	EventController::destroy();
}

void Engine::terminate() {
	glfwTerminate();
}

void Engine::init() {

	Window::init();
	window = Window::getWindow();
	GUIcanvas::setWindow(window);


	ShapeController::setWindow(window);
	ShapeController::initShader();
	levelShapeController = new ShapeController();
	GUIcanvas::init();

	start = std::chrono::system_clock::now();
	player = Player();
	PlayerBindingEvent::player = &player;

	AnimationController::setTimePointer(&frameTime);

	EventController::currentTime = &currentTime;

	LevelEvent::setShapeGroupsSize(10);
	LevelEvent::setShapeController(levelShapeController);
	EventController::loadLevel("a");

//	EventController::saveLevel("a", EventController::level);

	float vertexCoords[] = {0.f, 0.f, 0.f, 10.f, 10.f, 0.f, 10.f, 10.f};
	float vertexColors[] = {1.f, 0.f, 0.f, 1.f, 1.f, 0.f, 0.f, 1.f, 0.f, 0.f, 0.f, 1.f, 0.f, 0.f, 0.f, 1.f};
	uint vertexIDs[] = {0, 1, 2, 1, 2, 3};
	Shape shape(4, vertexCoords, vertexColors, 6, vertexIDs, 1, 0, 0, 0);
	ShapeGroup ass(shape);

	ButtonSex* buttonSex = new ButtonSex(0.f, 0.f, ass, -2000.f, 1000.f, -2000.f, 1000.f);
	GUIcanvas::addGUIobject(buttonSex);

}

void Engine::pollEvents() {
	glfwPollEvents();
}

void Engine::update() {
	pollEvents();
	pollKeyEvents();
	auto end = std::chrono::system_clock::now();
	frameTime = std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count() - currentTime;
	currentTime = std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();
	EventController::update();
	AnimationController::update();
	GUIcanvas::update();
}

void Engine::render() {
	Window::clear();
//	levelShapeController->draw();
//	GUIcanvas::draw();
	glfwSwapBuffers(window);
}

bool Engine::running() {
	return Window::running();
}

void Engine::pollKeyEvents() {
	if (IS_RIGHT_KEY_PRESSED && IS_LEFT_KEY_PRESSED) {
		if (player.lastDirectionX == 1) {
			player.move(-1.f, 0.f);
		} else player.move(1.f, 0.f);
	}
	else if (IS_LEFT_KEY_PRESSED) {
		player.move(-1.f, 0.f);
		player.lastDirectionX = -1;
	}
	else if (IS_RIGHT_KEY_PRESSED) {
		player.move(1.f, 0.f);
		player.lastDirectionX = 1;
	}
	if (IS_DOWN_KEY_PRESSED && IS_UP_KEY_PRESSED) {
		if (player.lastDirectionY == 1) {
			player.move(0.f, -1.f);
		}
		else player.move(0.f, 1.f);
	}
	else if (IS_DOWN_KEY_PRESSED) {
		player.move(0.f, -1.f);
		player.lastDirectionY = -1;
	}
	else if (IS_UP_KEY_PRESSED) {
		player.move(0.f, 1.f);
		player.lastDirectionY = 1;
	}
}

#include "EventController.h"
#include "LevelEvent\LevelEvent.h"

#include <iostream>
#include <fstream>
#include <vector>
#include "ByteArray.h"

#include "crtdbg.h"
#include "..\include\CRTDBG\mydbgnew.h"
#ifdef _DEBUG
#define new MYDEBUG_NEW
#endif

#define CREATE_EVENT create(byteLevel, initTime)

std::vector<LevelEvent*> EventController::level;
int EventController::currentEvent = 0;
float* EventController::currentTime = nullptr;

void EventController::update() 
{
	while (currentEvent < level.size() && level[currentEvent]->getInitTime() < *currentTime) {
		level[currentEvent]->start();
//		delete level[currentEvent];
		currentEvent++;
	}
}

void EventController::destroy()
{
	for (auto a : level) {
		delete a;
	}
	level.~vector();
}


void EventController::loadLevel(std::string path) {
	for (int i = 0; i < level.size(); i++) delete level[i];
	level.clear();

	std::ifstream fin;
	fin.open("raid_na_derevene.lvl", std::ifstream::binary);
	unsigned int byteLevelSize;
	unsigned int size;
	unsigned int checkSum;

	unsigned int offset = 0;

	fin.read((char*)(&byteLevelSize), sizeof(byteLevelSize));
	fin.read((char*)(&size), sizeof(size));
	fin.read((char*)(&checkSum), sizeof(checkSum));

	ByteArray* byteLevel = new ByteArray(byteLevelSize);

	fin.read(byteLevel->getDataPointer(), byteLevelSize);

	fin.close();
	level.resize(size);
	for (unsigned int i = 0; i < size; i++) {
		LevelEventType type = LevelEventType::EMPTY;
		float initTime;
		unsigned int blockSize;

		*byteLevel >> type >> initTime >> blockSize;

		switch (type) {
		case LevelEventType::EMPTY:
			break;
		case LevelEventType::BACKGROUND_COLOR_ANIMATION:
			level[i] = BackgroundColorAnimationEvent::CREATE_EVENT;
			break;
		case LevelEventType::CAMERA_ANIMATION:
			level[i] = CameraAnimationEvent::CREATE_EVENT;
			break;
		case LevelEventType::SHAPE_SPAWN:
			level[i] = ShapeSpawnEvent::CREATE_EVENT;
			break;
		case LevelEventType::SHAPE_GROUP_SPAWN:
			level[i] = ShapeGroupSpawnEvent::CREATE_EVENT;
			break;
		case LevelEventType::SHAPE_GROUP_DESTRUCTION:
			level[i] = ShapeGroupDestructionEvent::CREATE_EVENT;
			break;
		case LevelEventType::SHAPE_ANIMATION:
			level[i] = ShapeAnimationEvent::CREATE_EVENT;
			break;
		case LevelEventType::SHAPE_GROUP_ANIMATION:
			level[i] = ShapeGroupAnimationEvent::CREATE_EVENT;
			break;
		case LevelEventType::PLAYER_BINDING:
			level[i] = PlayerBindingEvent::CREATE_EVENT;
			break;
		default:
			break;
		}
		offset += blockSize;
	}

	delete byteLevel;
	byteLevel = nullptr;
}

void EventController::saveLevel(std::string path, std::vector<LevelEvent*>& level) {
	unsigned int size = level.size();
	unsigned int checkSum = 0;

	std::vector<ByteArray> byteLevel(size);

	unsigned int byteLevelSize = 0;

	for (unsigned int i = 0; i < size; i++) {
		LevelEventType type = level[i]->getType();
		float initTime = level[i]->getInitTime();
		ByteArray tempArray = level[i]->getByteArray();
		unsigned int blockSize = tempArray.getSize();
		byteLevel[i] = ByteArray(tempArray.getSize() + sizeof(type) + sizeof(initTime) + sizeof(blockSize));

		unsigned int offset = 0;
		byteLevel[i].add(type);
		byteLevel[i].add(initTime);
		byteLevel[i].add(blockSize);
		byteLevel[i].add(tempArray);

		byteLevelSize += static_cast<unsigned int>(byteLevel[i].getSize());
	}

	unsigned int offset = 0;

	ByteArray fileData(byteLevelSize + sizeof(byteLevelSize) + sizeof(size) + sizeof(checkSum));
	fileData.add(byteLevelSize);
	fileData.add(size);
	fileData.add(checkSum);

//	unsigned int tempOffset = offset;
//	unsigned int* value = (unsigned int*)(fileData + offset);

	for (unsigned int i = 0; i < size; i++) fileData.add(byteLevel[i]);

//	int valueCount = (byteLevelSize - offset) / 4;
//	for (int i = 0; i < valueCount; i++) checkSum += *(value + i);
//	writeToByteArray(fileData, (char*)&checkSum, tempOffset, sizeof(checkSum));

	std::ofstream fout;
	fout.open("raid_na_derevene.lvl", std::ofstream::binary);
	fout.write(fileData.getDataPointer(), byteLevelSize + sizeof(byteLevelSize) + sizeof(size) + sizeof(checkSum));
	fout.close();

	byteLevel.clear();
}

#include "GUI.h"
#include <iostream>

#include "crtdbg.h"
#include "..\include\CRTDBG\mydbgnew.h"
#ifdef _DEBUG
#define new MYDEBUG_NEW
#endif

GUIinteractiveObject::GUIinteractiveObject(
	float positionX,
	float positionY,
	ShapeGroup shapeGroup,
	float LeftBorderX,
	float RightBorderX,
	float UpBorderY,
	float BottomBorderY
) : GUIobject(positionX, positionY, shapeGroup) {
	this->LeftBorderX	= LeftBorderX;
	this->RightBorderX	= RightBorderX;
	this->UpBorderY		= UpBorderY;
	this->BottomBorderY	= BottomBorderY;

}

bool GUIinteractiveObject::checkCollision(float x, float y){
	return x < RightBorderX && x > LeftBorderX && y > UpBorderY && y < BottomBorderY;
}

GUIobject::~GUIobject() {}

GUIobject::GUIobject(float positionX, float positionY, ShapeGroup shapeGroup) {
	this->positionX = positionX;
	this->positionY = positionY;
	this->shapeGroup = shapeGroup;
}

ShapeGroup GUIobject::getShapeGroup() {
	return shapeGroup;
}

bool ButtonSex::interact(bool mouseButtonStates[3], float x, float y) {
	if (!state && checkCollision(x, y) && mouseButtonStates[0]) { 
		std::cout << "sex\n";
		this->state = true;
	}
	if (!mouseButtonStates[0]) {
		this->state = false;
		return false;
	}

	return true;
}

ButtonSex::ButtonSex(
	float positionX,
	float positionY,
	ShapeGroup shapeGroup,
	float LeftBorderX,
	float RightBorderX,
	float UpBorderY,
	float BottomBorderY
): GUIinteractiveObject(
	positionX,
	positionY,
	shapeGroup,
	LeftBorderX,
	RightBorderX,
	UpBorderY,
	BottomBorderY
) {
	this->state = false;
}

#include "GUIcanvas.h"
#include <iostream>

bool GUIcanvas::mouseButtonStates[] = {false, false, false};
double GUIcanvas::mousePositionX = 0;
double GUIcanvas::mousePositionY = 0;
GLFWwindow* GUIcanvas::window = nullptr;
ShapeController* GUIcanvas::shapeController = nullptr;

std::vector<GUIinteractiveObject*> GUIcanvas::objects(0);

int GUIcanvas::currentButtonID = -1;

void GUIcanvas::update() {

	glfwGetCursorPos(window, &mousePositionX,  &mousePositionY);
	for (int i = 0; i < sizeof(mouseButtonStates); i++) {
		mouseButtonStates[i] = glfwGetMouseButton(window, i);
	}
	GUIcanvas::interact();
}

void GUIcanvas::interact() {
	if (currentButtonID >= 0) {
		if (!objects[currentButtonID]->interact(mouseButtonStates, (float)mousePositionX, (float)mousePositionY)) {
			currentButtonID = -1;
			
		}
	}
	else
	for (int i = 0; i < objects.size(); i++) {
		if (objects[i]->interact(mouseButtonStates, (float)mousePositionX, (float)mousePositionY)) {
			currentButtonID = i;
		}
	}
}

void GUIcanvas::draw() {
	shapeController->draw();
}

void GUIcanvas::addGUIobject(GUIinteractiveObject* object) {
	objects.push_back(object);
	shapeController->addShapeGroup(object->getShapeGroup());
}

void GUIcanvas::setWindow(GLFWwindow* window) {
	GUIcanvas::window = window;
}

void GUIcanvas::init() {
	GUIcanvas::shapeController = new ShapeController();
}

#include <vector>
#include <iostream>
#include "Engine.h"
#include "ByteArray.h"

#include "crtdbg.h"
#include "..\include\CRTDBG\mydbgnew.h"
#ifdef _DEBUG
#define new MYDEBUG_NEW
#endif

void sex()
{
	std::cout << "$3cks" << "\n";
}



int main()
{
//	Engine engine = Engine();

	Engine::init();
	while (Engine::running()) {

		Engine::update();
		Engine::render();
	}

	Engine::terminate();
//	Engine::destroy();
//	_CrtMemDumpAllObjectsSince(NULL);
	return 0;
}

#include "Player.h"

#include "crtdbg.h"
#include "..\include\CRTDBG\mydbgnew.h"
#ifdef _DEBUG
#define new MYDEBUG_NEW
#endif

void Player::move(float dx, float dy) {
	if (positionX && positionY) {
		*positionX += dx * 0.01;
		*positionY += dy * 0.01;
	}
}

void Player::setTarget(float* positionX, float* positionY) {
	this->positionX = positionX;
	this->positionY = positionY;
}

#include "Shape.h"
#include "ByteArray.h"

#include "crtdbg.h"
#include "..\include\CRTDBG\mydbgnew.h"
#ifdef _DEBUG
#define new MYDEBUG_NEW
#endif

Shape::Shape() {
	this->EBOsize = 0;
	this->alphaChannel = 0.f;
	this->layer = 0;
	this->positionX = 0.f;
	this->positionY = 0.f;
	this->vertexCount = 0;
	this->vertexCoords = nullptr;
	this->vertexColors = nullptr;
	this->vertexIDs = nullptr;
}
Shape::Shape(
	uint vertexCount,
	float* vertexCoords,
	float* vertexColors,
	uint EBOsize,
	uint* vertexIDs,
	float alphaChannel,
	float positionX,
	float positionY,
	int layer
) {
	this->vertexCount = vertexCount;

	this->vertexCoords = new float[static_cast<long long>(vertexCount) * 2];
	this->vertexColors = new float[static_cast<long long>(vertexCount) * 4];

	for (uint i = 0; i < vertexCount * 2; i++) this->vertexCoords[i] = vertexCoords[i];
	for (uint i = 0; i < vertexCount * 4; i++) this->vertexColors[i] = vertexColors[i];

	this->EBOsize = EBOsize;

	this->vertexIDs = new uint[EBOsize];
	for (uint i = 0; i < EBOsize; i++) this->vertexIDs[i] = vertexIDs[i];

	this->alphaChannel = alphaChannel;
	this->positionX = positionX;
	this->positionY = positionY;

	this->layer = layer;
}

Shape::Shape(const Shape& shape) {
	this->vertexCount = shape.vertexCount;

	this->vertexCoords = new float[static_cast<size_t>(vertexCount) * 2];
	this->vertexColors = new float[static_cast<size_t>(vertexCount) * 4];

	for (uint i = 0; i < shape.vertexCount * 2; i++) this->vertexCoords[i] = shape.vertexCoords[i];
	for (uint i = 0; i < shape.vertexCount * 4; i++) this->vertexColors[i] = shape.vertexColors[i];

	this->EBOsize = shape.EBOsize;

	this->vertexIDs = new uint[shape.EBOsize];
	for (uint i = 0; i < EBOsize; i++) this->vertexIDs[i] = shape.vertexIDs[i];

	this->alphaChannel = shape.alphaChannel;
	this->positionX = shape.positionX;
	this->positionY = shape.positionY;

	this->layer = shape.layer;
}

Shape::Shape(ByteArray* byteArray) {
	*byteArray >> vertexCount >> EBOsize >> layer >> alphaChannel >> positionX >> positionY;
	vertexCoords = new float[static_cast<size_t>(vertexCount) * 2];
	vertexColors = new float[static_cast<size_t>(vertexCount) * 4];
	vertexIDs = new uint[EBOsize];
	byteArray->read(vertexCoords, sizeof(*vertexCoords) * vertexCount * 2);
	byteArray->read(vertexColors, sizeof(*vertexColors) * vertexCount * 4);
	byteArray->read(vertexIDs, sizeof(*vertexIDs) * EBOsize);
}

ByteArray Shape::getByteArray() {
	ByteArray byteArray(
		sizeof(vertexCount) +
		sizeof(EBOsize) +
		sizeof(layer) +
		sizeof(alphaChannel) +
		sizeof(positionX) +
		sizeof(positionY) +
		sizeof(*vertexIDs) * EBOsize +
		sizeof(*vertexCoords) * vertexCount * 2 +
		sizeof(*vertexColors) * vertexCount * 4
	);
	byteArray << vertexCount << EBOsize << layer << alphaChannel << positionX << positionY;
	byteArray.add(vertexCoords, sizeof(*vertexCoords) * vertexCount * 2);
	byteArray.add(vertexColors, sizeof(*vertexColors) * vertexCount * 4);
	byteArray.add(vertexIDs, sizeof(*vertexIDs) * EBOsize);

	return byteArray;
}

Shape::~Shape() {
	delete[] vertexCoords;	
	delete[] vertexColors;
	delete[] vertexIDs;
	vertexColors = nullptr;
	vertexCoords = nullptr;
	vertexIDs = nullptr;
}

Shape& Shape::operator=(const Shape& shape) {
	delete[] vertexCoords;
	delete[] vertexColors;
	delete[] vertexIDs;

	this->vertexCount = shape.vertexCount;

	this->vertexCoords = new float[static_cast<size_t>(vertexCount) * 2];
	this->vertexColors = new float[static_cast<size_t>(vertexCount) * 4];

	for (uint i = 0; i < shape.vertexCount * 2; i++) this->vertexCoords[i] = shape.vertexCoords[i];
	for (uint i = 0; i < shape.vertexCount * 4; i++) this->vertexColors[i] = shape.vertexColors[i];

	this->EBOsize = shape.EBOsize;

	this->vertexIDs = new uint[shape.EBOsize];
	for (uint i = 0; i < EBOsize; i++) this->vertexIDs[i] = shape.vertexIDs[i];

	this->alphaChannel = shape.alphaChannel;
	this->positionX = shape.positionX;
	this->positionY = shape.positionY;

	this->layer = shape.layer;

	return *this;
}

uint Shape::getVertexCount() const {
	return vertexCount;
}

uint Shape::getEBOsize() const {
	return EBOsize;
}

float* Shape::getVertexCoordsPointer() {
	return vertexCoords;
}

float* Shape::getVertexColorsPointer() {
	return vertexColors;
}

uint* Shape::getVertexIDsPointer() {
	return vertexIDs;
}

float* Shape::getAlphaChannelPointer() {
	return &alphaChannel;
}

float* Shape::getPositionXpointer() {
	return &positionX;
}

float* Shape::getPositionYpointer() {
	return &positionY;
}

int Shape::getLayer() const {
	return layer;
}

#include "ShapeController.h"
#include <iostream>

#include "crtdbg.h"
#include "..\include\CRTDBG\mydbgnew.h"
#ifdef _DEBUG
#define new MYDEBUG_NEW
#endif


const char* vertexShaderSource = "#version 330 core\n"
"layout (location = 0) in vec2 pos;\n"
"layout (location = 1) in vec4 color;\n"

"layout(std140) uniform Camera"
"{"
"	vec2 offset;"
"	vec2 scale;"
"};"
"out vec4 vertexColor;\n"
"void main()\n"
"{\n"
"   gl_Position = vec4((pos-offset)*scale, 0.f, 1.f);\n"
"   vertexColor = color;\n"
"}\0";

const char* fragmentShaderSource = "#version 330 core\n"
"out vec4 FragColor;\n"
"in vec4 vertexColor;\n"
"void main()\n"
"{\n"
"   FragColor = vertexColor;\n"
"}\n\0";

GLFWwindow* ShapeController::window = nullptr;
int ShapeController::shader = 0;

void ShapeController::updateBuffers() {
	uint positionOffsetCounter = 0;
	uint colorOffsetCounter = vertexCount * 2;

	writeToVertexbuffer(shapeGroup, positionOffsetCounter, colorOffsetCounter, 1.f, 0, 0);
}

void ShapeController::writeToVertexbuffer(
	ShapeGroup &shapeGroup,
	uint& positionOffsetCounter,
	uint& colorOffsetCounter,
	float alphaChannel,
	float positionX,
	float positionY
) {
	alphaChannel *= *shapeGroup.getAlphaChannelPointer();
	positionX += *shapeGroup.getPositionXpointer();
	positionY += *shapeGroup.getPositionYpointer();

	Shape* shapes = shapeGroup.getShapesPointer();
	std::list<ShapeGroup> shapeGroups = shapeGroup.getShapeGroups();

	for (int i = 0; i < shapeGroup.getShapeCount(); i++) {
		float* shapeVertexCoords = shapes[i].getVertexCoordsPointer();
		float* shapeVertexColors = shapes[i].getVertexColorsPointer();

		uint shapeVertexCount = shapes[i].getVertexCount();
		
		for (int j = 0; j < shapeVertexCount * 2; j += 2) {
			vertexBuffer[positionOffsetCounter + j] = shapeVertexCoords[j] + positionX + *shapes[i].getPositionXpointer();
			vertexBuffer[positionOffsetCounter + j + 1] = shapeVertexCoords[j + 1] + positionY + *shapes[i].getPositionYpointer();
		}
		positionOffsetCounter += shapeVertexCount * 2;

		for (int j = 0; j < shapeVertexCount * 4; j += 4) {
			vertexBuffer[colorOffsetCounter + j] = shapeVertexColors[j];
			vertexBuffer[colorOffsetCounter + j + 1] = shapeVertexColors[j + 1];
			vertexBuffer[colorOffsetCounter + j + 2] = shapeVertexColors[j + 2];
			vertexBuffer[colorOffsetCounter + j + 3] = shapeVertexColors[j + 3] * (*shapes[i].getAlphaChannelPointer()) * alphaChannel;
		}
		colorOffsetCounter += shapeVertexCount * 4;
	}
	for (auto &shapeGroup : shapeGroups) {
		writeToVertexbuffer(shapeGroup, positionOffsetCounter, colorOffsetCounter, alphaChannel, positionX, positionY);
	}
}

void ShapeController::writeToEBObuffer(
	ShapeGroup &shapeGroup, 
	uint &EBOoffsetCounter, 
	uint& vertexCounter
) {
	for (int i = 0; i < shapeGroup.getShapeCount(); i++) {
		for (int j = 0; j < shapeGroup.getShapesPointer()[i].getEBOsize(); j++) {
			EBObuffer[EBOoffsetCounter + j] = shapeGroup.getShapesPointer()[i].getVertexIDsPointer()[j] + vertexCounter;
		}
		EBOoffsetCounter += shapeGroup.getShapesPointer()[i].getEBOsize();
		vertexCounter += shapeGroup.getShapesPointer()[i].getVertexCount();
	}
	for (auto& shapeGroup : shapeGroup.getShapeGroups()) {
		writeToEBObuffer(shapeGroup, EBOoffsetCounter, vertexCounter);
	}
}

void ShapeController::reallocateBuffers() {
	free(vertexBuffer);
	vertexBuffer = (float*)malloc(vertexCount * VERTEX_SIZE * sizeof(*vertexBuffer));

	delete[] EBObuffer;
	EBObuffer = (uint*)malloc(sizeof(*EBObuffer) * EBOsize);
	uint EBOoffsetCounter = 0;
	uint vertexCounter = 0;

	writeToEBObuffer(shapeGroup, EBOoffsetCounter, vertexCounter);
	glBindVertexArray(VAO);
	glBindBuffer(GL_ARRAY_BUFFER, VBO);
	
	glVertexAttribPointer(
		VERTEX_ATTRIB_ARRAY_2,
		4,
		GL_FLOAT,
		GL_FALSE,
		4 * sizeof(GLfloat),
		(GLvoid*)(2 * vertexCount * sizeof(*vertexBuffer))
	);
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(*EBObuffer) * EBOsize, EBObuffer, GL_STATIC_DRAW);
	
	glBindBuffer(GL_ARRAY_BUFFER, 0);
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
	glBindVertexArray(0);
}

void ShapeController::initBuffers() {
	
	glGenBuffers(1, &CDB);
	glBindBuffer(GL_UNIFORM_BUFFER, CDB);
		
	glUniformBlockBinding(
		shader,
		glGetUniformBlockIndex(shader, "Camera"),
		1
	);
	glBindBufferBase(GL_UNIFORM_BUFFER, 1, CDB);
	

	glGenBuffers(1, &VBO);
	glBindBuffer(GL_ARRAY_BUFFER, VBO);

	glGenBuffers(1, &EBO);

	glGenVertexArrays(1, &VAO);
	
	glBindVertexArray(VAO);

	glVertexAttribPointer(
		VERTEX_ATTRIB_ARRAY_1,
		2,
		GL_FLOAT,
		GL_FALSE,
		2 * sizeof(GLfloat),
		(GLvoid*)0

	);

	
	glBindBuffer(GL_UNIFORM_BUFFER, 0);
	glBindBuffer(GL_ARRAY_BUFFER, 0);
	glBindVertexArray(0);
}

void ShapeController::initShader() {
	int vertexShader = glCreateShader(GL_VERTEX_SHADER);
	glShaderSource(vertexShader, 1, &vertexShaderSource, NULL);
	glCompileShader(vertexShader);

	int success;
	char infoLog[512];
	glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &success);
	if (!success) {
		glGetShaderInfoLog(vertexShader, 512, NULL, infoLog);
		std::cout << "ERROR::SHADER::VERTEX::COMPILATION_FAILED\n" << infoLog << std::endl;
	}

	int fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);
	glShaderSource(fragmentShader, 1, &fragmentShaderSource, NULL);
	glCompileShader(fragmentShader);

	glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &success);
	if (!success) {
		glGetShaderInfoLog(fragmentShader, 512, NULL, infoLog);
		std::cout << "ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n" << infoLog << std::endl;
	}

	shader = glCreateProgram();
	glAttachShader(shader, vertexShader);
	glAttachShader(shader, fragmentShader);
	glLinkProgram(shader);

	glGetProgramiv(shader, GL_LINK_STATUS, &success);
	if (!success) {
		glGetProgramInfoLog(shader, 512, NULL, infoLog);
		std::cout << "ERROR::SHADER::PROGRAM::LINKING_FAILED\n" << infoLog << std::endl;
	}

	glDeleteShader(vertexShader);
	glDeleteShader(fragmentShader);
}

void ShapeController::destroy()
{
	shapeGroup.~ShapeGroup();
}

float* ShapeController::getCameraValuePointer(uint valueNum) {
	return &cameraDataBuffer[valueNum];
}

void ShapeController::draw() {
	updateBuffers();
	glBindVertexArray(VAO);
	glBindBuffer(GL_ARRAY_BUFFER, VBO);
	glEnableVertexAttribArray(VERTEX_ATTRIB_ARRAY_1);
	glEnableVertexAttribArray(VERTEX_ATTRIB_ARRAY_2);
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
	glBindBuffer(GL_UNIFORM_BUFFER, CDB);

	glBufferData(
		GL_ARRAY_BUFFER,
		sizeof(float) * vertexCount * VERTEX_SIZE,
		vertexBuffer,
		GL_STREAM_DRAW
	);

	glBufferData(
		GL_UNIFORM_BUFFER,
		sizeof(float) * 4,
		cameraDataBuffer,
		GL_STATIC_DRAW
	);

	glUseProgram(shader);

	
	glDrawElements(GL_TRIANGLES, EBOsize, GL_UNSIGNED_INT, 0);
	glDisableVertexAttribArray(VERTEX_ATTRIB_ARRAY_1);
	glDisableVertexAttribArray(VERTEX_ATTRIB_ARRAY_2);
	glBindBuffer(GL_ARRAY_BUFFER, 0);
	glBindBuffer(GL_UNIFORM_BUFFER, 0);
	glBindVertexArray(0);

}

std::list<ShapeGroup>::iterator ShapeController::addShapeGroup(const ShapeGroup& shapeGroup) {
	vertexCount += shapeGroup.getVertexCount();
	EBOsize += shapeGroup.getEBOsize();
	std::list<ShapeGroup>::iterator otherShapeGroupIterator = ShapeController::shapeGroup.addShapeGroup(shapeGroup);
	reallocateBuffers();
	return otherShapeGroupIterator;
}

std::list<ShapeGroup>::iterator ShapeController::addShapeGroup(
	const ShapeGroup& shapeGroup, 
	const std::list<ShapeGroup>::iterator& shapeGroupIterator
) {
	vertexCount += shapeGroup.getVertexCount();
	EBOsize += shapeGroup.getEBOsize();
	std::list<ShapeGroup>::iterator otherShapeGroupIterator = (*shapeGroupIterator).addShapeGroup(shapeGroup);
	reallocateBuffers();
	return otherShapeGroupIterator;
}

void ShapeController::setWindow(GLFWwindow* window) {
	ShapeController::window = window;
}

void ShapeController::removeShapeGroup(std::list<ShapeGroup>::iterator& shapeGroupIterator) {
	vertexCount -= (*shapeGroupIterator).getVertexCount();
	EBOsize -= (*shapeGroupIterator).getEBOsize();

	shapeGroup.removeShapeGroup(shapeGroupIterator);
	reallocateBuffers();
}

ShapeController::ShapeController() {
	this->shapeGroup = ShapeGroup(0, nullptr, 1.f, 0.f, 0.f, 0);

	this->vertexCount = 0;
	this->vertexBuffer = (float*)malloc(0);

	this->bufferID = 0;

	this->EBOsize = 0;
	this->EBObuffer = (uint*)malloc(0);

	this->cameraDataBuffer[0] = 0.f;
	this->cameraDataBuffer[1] = 0.f;
	this->cameraDataBuffer[2] = 0.1f / 16.f * 9.f;
	this->cameraDataBuffer[3] = 0.1f;

	this->VBO = 0;
	this->VAO = 0;
	this->EBO = 0;
	this->CDB = 0;
	if (window) {
		initBuffers();
	}
//  glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
	glEnable(GL_BLEND);
	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
}
/*
ShapeController& ShapeController::operator=(const ShapeController& shapeController) {
	free(EBObuffer);
	free(vertexBuffer);

	this->shapeGroup = shapeController.shapeGroup;

	this->vertexCount = shapeController.vertexCount;
	this->vertexBuffer = (float*)malloc(vertexCount * 6);

	this->bufferID = shapeController.bufferID;

	this->EBOsize = shapeController.EBOsize;
	this->EBObuffer = (uint*)malloc(EBOsize);

	this->cameraDataBuffer[0] = 0.f;
	this->cameraDataBuffer[1] = 0.f;
	this->cameraDataBuffer[2] = 0.1f / 16.f * 9.f;
	this->cameraDataBuffer[3] = 0.1f;

	this->VBO = shapeController.VBO;
	this->VAO = shapeController.VAO;
	this->EBO = shapeController.EBO;
	this->CDB = shapeController.CDB;
	
	if (window) {
		initBuffers();
	}
	return *this;
}

ShapeController::ShapeController(const ShapeController& shapeController) {
	this->shapeGroup = shapeController.shapeGroup;

	this->vertexCount = shapeController.vertexCount;
	this->vertexBuffer = (float*)malloc(vertexCount*6);

	this->bufferID = shapeController.bufferID;

	this->EBOsize = shapeController.EBOsize;
	this->EBObuffer = (uint*)malloc(EBOsize);

	this->cameraDataBuffer[0] = 0.f;
	this->cameraDataBuffer[1] = 0.f;
	this->cameraDataBuffer[2] = 0.1f / 16.f * 9.f;
	this->cameraDataBuffer[3] = 0.1f;

	this->VBO = shapeController.VBO;
	this->VAO = shapeController.VAO;
	this->EBO = shapeController.EBO;
	this->CDB = shapeController.CDB;

	this->shader = shapeController.shader;
}
*/

ShapeController::~ShapeController() {
	free(EBObuffer);
	free(vertexBuffer);
	this->vertexBuffer = nullptr;
	this->EBObuffer = nullptr;
	if (window) {
		glDeleteVertexArrays(1, &VAO);
		glDeleteBuffers(1, &VBO);
		glDeleteBuffers(1, &EBO);
		glDeleteBuffers(1, &CDB);
	}
}

#include "ShapeGroup.h"
#include "ByteArray.h"

#include "crtdbg.h"
#include "..\include\CRTDBG\mydbgnew.h"
#ifdef _DEBUG
#define new MYDEBUG_NEW
#endif

ShapeGroup::ShapeGroup() {
	this->shapeCount = 0;
	this->shapes = nullptr;
	this->alphaChannel = 1.f;
	this->positionX = 0.f;
	this->positionY = 0.f;
	this->layer = 0;
}
ShapeGroup::ShapeGroup(
	uint shapeCount,
	Shape* shapes,
	float alphaChannel,
	float positionX,
	float positionY,
	int layer
) {
	this->shapeCount = shapeCount;

	this->shapes = new Shape[shapeCount];
	for (int i = 0; i < shapeCount; i++) this->shapes[i] = shapes[i];

	this->shapeGroups = shapeGroups;

	this->alphaChannel = alphaChannel;
	this->positionX = positionX;
	this->positionY = positionY;
	this->layer = layer;
}

ShapeGroup::ShapeGroup(const Shape& shape) {
	this->shapeCount = 1;

	this->layer = shape.getLayer();
	this->shapes = new Shape[1] {shape};
	this->shapeGroups = std::list<ShapeGroup>();
	this->alphaChannel = 1.f;
	this->positionX = 0.f;
	this->positionY = 0.f;
}

ShapeGroup::ShapeGroup(const ShapeGroup& shapeGroup) {
	this->layer = shapeGroup.layer;
	this->alphaChannel = shapeGroup.alphaChannel;
	this->positionX = shapeGroup.positionX;
	this->positionY = shapeGroup.positionY;

	this->shapeCount = shapeGroup.shapeCount;

	this->shapes = new Shape[shapeGroup.shapeCount];
	this->shapeGroups = shapeGroups;

	for (int i = 0; i < shapeGroup.shapeCount; i++) this->shapes[i] = shapeGroup.shapes[i];
}

ShapeGroup::ShapeGroup(ByteArray* byteArray) {
	unsigned int shapeGroupCount;
	shapeGroups = std::list<ShapeGroup>();
	*byteArray >> shapeCount >> shapeGroupCount >> layer >> alphaChannel >> positionX >> positionY;
	shapes = new Shape[shapeCount];
	for (int i = 0; i < shapeCount; i++)
		shapes[i] = Shape(byteArray);
	for (int i = 0; i < shapeGroupCount; i++)
		shapeGroups.push_back(ShapeGroup(byteArray));
}

ByteArray ShapeGroup::getByteArray() {
	unsigned int shapeGroupCount = shapeGroups.size();
	std::vector<ByteArray> byteShapes(shapeCount);
	std::vector<ByteArray> byteShapeGroups(shapeGroupCount);
	unsigned int byteArraySize =
		sizeof(shapeCount) +
		sizeof(shapeGroupCount) +
		sizeof(layer) +
		sizeof(alphaChannel) +
		sizeof(positionX) +
		sizeof(positionY);

	for (int i = 0; i < shapeCount; i++) {
		byteShapes[i] = shapes[i].getByteArray();
		byteArraySize += byteShapes[i].getSize();
	}
	if (shapeGroupCount) {
		int i = 0;
		for (auto& shapeGroup : shapeGroups) {
			byteShapeGroups[i] = shapeGroup.getByteArray();
			byteArraySize += byteShapeGroups[i].getSize();
			i++;
		}
	}
	ByteArray byteArray(byteArraySize);
	byteArray << shapeCount << shapeGroupCount << layer << alphaChannel << positionX << positionY;
	for (int i = 0; i < byteShapes.size(); i++)
		byteArray.add(byteShapes[i]);
	if (shapeGroupCount)
		for (int i = 0; i < byteShapeGroups.size(); i++)
			byteArray.add(byteShapeGroups[i]);
	return byteArray;
}

ShapeGroup& ShapeGroup::operator=(const ShapeGroup& shapeGroup) {
	delete[] shapes;

	this->layer = shapeGroup.layer;
	this->alphaChannel = shapeGroup.alphaChannel;
	this->positionX = shapeGroup.positionX;
	this->positionY = shapeGroup.positionY;

	this->shapeCount = shapeGroup.shapeCount;

	this->shapes = new Shape[shapeGroup.shapeCount];
	this->shapeGroups = shapeGroups;

	for (int i = 0; i < shapeGroup.shapeCount; i++) this->shapes[i] = shapeGroup.shapes[i];

	return *this;
}

std::list<ShapeGroup>::iterator ShapeGroup::addShapeGroup(const ShapeGroup &shapeGroup) {
	std::list<ShapeGroup>::iterator i = shapeGroups.begin();
	while (i != shapeGroups.end() && (*i).layer < shapeGroup.layer) i++;
	return shapeGroups.insert(i, shapeGroup); 
}

void ShapeGroup::removeShapeGroup(const std::list<ShapeGroup>::iterator &shapeGroupIterator) {
	shapeGroups.erase(shapeGroupIterator);
	delete[] (*shapeGroupIterator).shapes;
	(*shapeGroupIterator).shapes = nullptr;
}

ShapeGroup::~ShapeGroup() {
	delete[] shapes;
	shapes = nullptr;
}

uint ShapeGroup::getEBOsize() const {
	uint size = 0;

	for (int i = 0; i < shapeCount; i++) size += shapes[i].getEBOsize();
	for (auto &shapeGroup : shapeGroups) size += shapeGroup.getEBOsize();

	return size;
}

uint ShapeGroup::getVertexCount() const {
	uint size = 0;

	for (int i = 0; i < shapeCount; i++) size += shapes[i].getVertexCount();
	for (auto &shapeGroup : shapeGroups) size += shapeGroup.getVertexCount();

	return size;
}

uint ShapeGroup::getShapeCount() const {
	return shapeCount;
}

Shape* ShapeGroup::getShapesPointer() {
	return shapes;
}

std::list<ShapeGroup> ShapeGroup::getShapeGroups() {
	return shapeGroups;
}

float* ShapeGroup::getAlphaChannelPointer() {
	return &alphaChannel;
}

float* ShapeGroup::getPositionXpointer() {
	return &positionX;
}

float* ShapeGroup::getPositionYpointer() {
	return &positionY;
}

int ShapeGroup::getLayer() const {
	return layer;
}

#include "Window.h"
#include <iostream>

#include "crtdbg.h"
#include "..\include\CRTDBG\mydbgnew.h"
#ifdef _DEBUG
#define new MYDEBUG_NEW
#endif

float Window::backgroundColor[4] = { 1.f, 1.f, 1.f, 1.f };
GLuint Window::currentBufferID = 1;
GLuint Window::currentAttribArrayID = 0;
GLFWwindow* Window::window = nullptr;

void Window::init() {
	glfwInit();
	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
	glfwWindowHint(GLFW_RESIZABLE, GL_FALSE);

	window = glfwCreateWindow(1920, 1080, "Genki.psd", nullptr, nullptr);
	if (window == nullptr) {
		std::cout << "Failed to create GLFW window" << std::endl;
		glfwTerminate();
	}
	glfwMakeContextCurrent(window);

	glewExperimental = GL_TRUE;
	if (glewInit() != GLEW_OK) {
		std::cout << "Failed to initialize GLEW" << std::endl;
	}
	int width, height;
	glfwGetFramebufferSize(window, &width, &height);
	glViewport(0, 0, width, height);
}

GLFWwindow* Window::getWindow() {
	return window;
}

float* Window::getBackgroundColorValuePointer(uint valueNum) {
	return &backgroundColor[valueNum];
}

bool Window::running() {
	return !glfwWindowShouldClose(window);
}

void Window::clear() {
	
	glClearColor(backgroundColor[0], backgroundColor[1], backgroundColor[2], backgroundColor[3]);
	glClear(GL_COLOR_BUFFER_BIT);
}

GLuint Window::generateBufferID() {
	return currentBufferID++;
}

GLuint Window::generateAttribArray() {
	return currentAttribArrayID++;
}
